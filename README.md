# Smart Bookmark App

A real-time, secure bookmark manager built with Next.js 14 and Supabase.

**[üöÄ Live Demo](https://smart-bookmark-5y3y7j2k5-mayankupadhyay-1260s-projects.vercel.app)** |  **[üíª GitHub Repository](https://github.com/mayankupadhyay-1260/Smart-Bookmark-App)**

---

## üìã Requirements & Features
This application was built to satisfy the following assessment requirements:
1.  **Google OAuth Only:** No email/password signups.
2.  **Private Data:** Users can only view/edit their own bookmarks (enforced via RLS).
3.  **Real-time Sync:** Updates propagate instantly across multiple tabs/windows.
4.  **CRUD:** Add and Delete functionality.

## üõ† Tech Stack
* **Framework:** Next.js 14 (App Router)
* **Backend:** Supabase (Auth, Database, Realtime)
* **Styling:** Tailwind CSS
* **Deployment:** Vercel

---

## üß† Challenges & Solutions (Engineering Decisions)

### 1. Real-time State Synchronization
**The Challenge:** Keeping the UI in sync across multiple tabs without manual refreshing or excessive API polling.
**The Solution:**
I utilized **Supabase Realtime** (`postgres_changes`).
* Instead of manually updating the local React state immediately after a form submission, I set up a `useEffect` listener on the client.
* The application listens for `INSERT` and `DELETE` events specifically on the `bookmarks` table.
* When a change occurs in the database (even from a different tab), the listener triggers a state update. This ensures the UI always reflects the "source of truth" in the database.

### 2. Data Privacy & Security (RLS)
**The Challenge:** Ensuring User A cannot access User B's bookmarks, even if they try to manipulate API calls.
**The Solution:**
I implemented PostgreSQL **Row Level Security (RLS)** policies.
* **SELECT:** `auth.uid() = user_id` (Users view only their own data).
* **INSERT:** `auth.uid() = user_id` (Users create data only for themselves).
* **DELETE:** `auth.uid() = user_id` (Users delete only their own data).
* *Outcome:* Security is handled at the database layer, not just the application layer.

### 3. Handling OAuth Redirects in Production
**The Challenge:** Google OAuth worked locally (`localhost:3000`) but initially failed on Vercel due to redirect URI mismatches.
**The Solution:**
* Configured the `NEXT_PUBLIC_SITE_URL` environment variable.
* Updated the Google Cloud Console "Authorized redirect URIs" to include the production Vercel URL (`https://project.vercel.app/auth/callback`).
* Ensured the Supabase Auth settings whitelisted the production domain.

---

## üß™ How to Test
To verify the requirements:

1.  **Auth:** Click "Sign in with Google."
2.  **Real-time:** Open the app in **two separate tabs**. Add a bookmark in Tab A. Watch it appear instantly in Tab B.
3.  **Privacy:** Open the app in a normal window (User A) and an Incognito window (User B). Verify that bookmarks added by User A are **not** visible to User B.

---

## üóÑÔ∏è Database Schema
The application uses a single table `bookmarks`.

```sql
create table bookmarks (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null default auth.uid(),
  title text not null,
git clone [https://github.com/your-username/smart-bookmark-app.git](https://github.com/your-username/smart-bookmark-app.git)
npm install
NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
npm run dev
  url text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
